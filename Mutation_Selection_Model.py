# -----------------------------------------------------------------------------------------------
# 
#
#
# Jonathan Holmes
#
# Permission to use, copy, modify, and/or distribute this software or any part thereof for any
# purpose with or without fee is hereby granted provided that:
#     (1) the original author is credited appropriately in the source code
#         and any accompanying documentation
# and (2) that this requirement is included in any redistribution.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
# SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
# THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
# OF THIS SOFTWARE.
#
# E-mail: jh795@leicester.ac.uk
# ------------------------------------------------------------------------------------------------
# 
#
#		This script was generated by converting the native R script defined in:	
#			Mutation and Selection in Bacteria: Modelling and Calibration
#			C. D. Bayliss, C. Fallaize, R. Howitt, and M. V. Tretyakov
#			Bull Math Biol. 2019; 81(3): 639â€“675
# 			https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6373360/
#
#			The code can be run by creating a variable to parse into the mutsel_model function
#			with the inputs: initdist,pqmat,gammamat,n,stattol,maxgen,l
#
# ------------------------------------------------------------------------------------------------

# Required functions
import os
import itertools
import numpy
import scipy
from scipy.spatial import distance
import sys

#In built functions

def	kronecker(a,b):
	c = (numpy.kron(a, b))
	return(c)

def binary(n):
	lst = list(itertools.product([0, 1], repeat=n))
	binarys = []
	for i in lst:
		b = []
		for I in i:
			b.append(str(I))
		binarys.append("".join(b))
	return binarys	
	
def tensorit(y):
	akl = numpy.zeros([1,len(y)*len(y)])
	aqq = numpy.zeros([len(y),len(y[0])])
	for i in range(0,len(y)):
		I = numpy.where(y[i] == numpy.amin(y[i]))
		min_ =  (I[0][0])
		y[i][min_] = 1
		aqq[i] = y[i]
		if i>0:
			akl = kronecker(akl, aqq[i])
		else:
			akl = aqq[i]
	return(akl,aqq)



def mutsel_model(initdist,pqmat,gammamat,n,stattol,maxgen,l):
	outdata = numpy.zeros([maxgen,pow(2,l)])
	stattime = 0
	statyes= ""
	if n>maxgen:
		n = maxgen
	bmatrix = numpy.array(initdist)

	gamx = 1/numpy.amin(gammamat)*gammamat

	for i in range(0,len(pqmat)):
		#	ax=matrix(c(1-pqmat[i,1],pqmat[i,1],pqmat[i,2],1-pqmat[i,2]),2,2,byrow=T)
		ax = numpy.array([[1-pqmat[i,0],pqmat[i,0]],[pqmat[i,1],1-pqmat[i,1]]])
		if i>0:
			axmatrix =kronecker(axmatrix,ax)
		else:
			axmatrix=ax


	imatrix = numpy.zeros([pow(2,l),pow(2,l)])
	i = 0
	for I in range(0, len(gamx)):
		imatrix[I][I] = gamx[I]

	p_q_exp = pqmat
	gamma_exp = gammamat
	inout = numpy.array(initdist)
	colnames = binary(l)
	i_axmatrix = numpy.matmul(axmatrix,imatrix)

	for i in range(1,maxgen):
		densub = numpy.matmul(bmatrix, axmatrix)
		denoma = numpy.matmul(densub,gammamat)

		totmatrix = (1/denoma)*numpy.matmul(bmatrix,i_axmatrix)
		for k in range(0,pow(2,l)):	
			outdata[i,k] = totmatrix[k]

		bmatrix = totmatrix

		if i == n:
			hayneg = outdata[n-1]
		if i == n:
			hay =outdata[n]
		if i>1:
			if numpy.linalg.norm(outdata[i] - outdata[i-1]) < stattol:
				stattime = i
				statyes = "YES"
				if stattime < n:
					hay = (outdata[stattime])
				break
		if i == maxgen - 1:
			statyes= "NO"
		i = i + 1
	hayout = numpy.array(hay)
	if statyes == "YES":
		hayoutstat = numpy.array(outdata[stattime,])
	if statyes == "NO":
		hayoutstat = "Stationary distribution not reached, over " + str(maxgen) + " generations"

	return(p_q_exp,gamma_exp,inout,hayout,hayoutstat,stattime,colnames,outdata)










